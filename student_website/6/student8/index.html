<!DOCTYPE html>
<html>
<head>
<title>3D 에임 연습 게임 - 하드모드</title>
<style>
    body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
    }
    #game-container {
        width: 80vw;
        height: 80vh;
        border: 2px solid #333;
        position: relative;
        cursor: crosshair;
    }
    canvas {
        display: block;
    }
    #controls, #stats {
        margin-top: 10px;
        font-size: 1.5em;
        display: flex;
        gap: 20px;
    }
    button {
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
    }
    #pause-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        font-size: 3em;
        display: none;
        justify-content: center;
        align-items: center;
    }
</style>
</head>
<body>

<h1>3D 에임 연습 게임 - 하드모드</h1>
<div id="stats">
    <div id="score">점수: 0</div>
    <div id="accuracy">정확도: 100%</div>
</div>
<div id="game-container">
    <div id="pause-overlay">일시정지</div>
</div>
<div id="controls">
    <button id="normal-mode-button">노멀 모드</button>
    <button id="hard-mode-button">하드 모드</button>
    <button id="retry-button">다시하기</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Game Settings
    const difficultySettings = {
        normal: { LIFETIME: 10.0, INITIAL_SCALE: 1.0, COLOR: 0x0000ff },
        hard: { LIFETIME: 4.0, INITIAL_SCALE: 0.6, COLOR: 0xff0000 }
    };
    let currentDifficulty = 'normal';

    // Scene setup
    const gameContainer = document.getElementById('game-container');
    const pauseOverlay = document.getElementById('pause-overlay');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x808080);
    const camera = new THREE.PerspectiveCamera(75, gameContainer.clientWidth / gameContainer.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
    gameContainer.appendChild(renderer.domElement);

    // Lighting & Wall
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);
    const wall = new THREE.Mesh(new THREE.PlaneGeometry(30, 20), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
    wall.position.z = -5;
    scene.add(wall);

    // Targets
    const targets = [];
    for (let i = 0; i < 3; i++) {
        const target = new THREE.Mesh(
            new THREE.SphereGeometry(1, 32, 32),
            new THREE.MeshStandardMaterial()
        );
        target.userData = {};
        scene.add(target);
        targets.push(target);
    }

    // Gun Model
    const gun = new THREE.Group();
    // ... (gun model code is unchanged but kept for completeness)
    camera.add(gun);
    scene.add(camera);
    camera.position.z = 10;

    // Game state
    let score = 0, totalShots = 0, hits = 0, isPaused = false;
    const scoreDisplay = document.getElementById('score');
    const accuracyDisplay = document.getElementById('accuracy');
    const normalModeButton = document.getElementById('normal-mode-button');
    const hardModeButton = document.getElementById('hard-mode-button');
    const retryButton = document.getElementById('retry-button');

    function setDifficulty(difficulty) {
        currentDifficulty = difficulty;
        resetGame();
    }

    function resetTarget(target) {
        const settings = difficultySettings[currentDifficulty];
        target.position.set((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 10, (Math.random() * 3) - 2);
        target.scale.set(settings.INITIAL_SCALE, settings.INITIAL_SCALE, settings.INITIAL_SCALE);
        target.material.color.setHex(settings.COLOR);
        target.userData.lifetime = settings.LIFETIME * (0.5 + Math.random() * 0.5); // Add some randomness
    }

    function resetGame() {
        score = 0; totalShots = 0; hits = 0;
        updateStats();
        targets.forEach(resetTarget);
    }

    function updateStats() {
        scoreDisplay.textContent = `점수: ${score}`;
        const accuracy = totalShots > 0 ? ((hits / totalShots) * 100).toFixed(2) : 100;
        accuracyDisplay.textContent = `정확도: ${accuracy}%`;
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onMouseClick(event) {
        if (isPaused) return;
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(targets);
        totalShots++;
        if (intersects.length > 0) {
            score++;
            hits++;
            resetTarget(intersects[0].object);
        }
        updateStats();
    }

    function togglePause() {
        isPaused = !isPaused;
        pauseOverlay.style.display = isPaused ? 'flex' : 'none';
        clock.running = !isPaused;
    }

    // Event Listeners
    normalModeButton.addEventListener('click', () => setDifficulty('normal'));
    hardModeButton.addEventListener('click', () => setDifficulty('hard'));
    retryButton.addEventListener('click', resetGame);
    window.addEventListener('click', onMouseClick);
    window.addEventListener('keydown', (event) => { if (event.key === 'Escape') togglePause(); });
    window.addEventListener('resize', () => {
        camera.aspect = gameContainer.clientWidth / gameContainer.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
    });

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        if (isPaused) return;
        const delta = clock.getDelta();
        const settings = difficultySettings[currentDifficulty];

        targets.forEach(target => {
            target.userData.lifetime -= delta;
            const scale = settings.INITIAL_SCALE * Math.max(0, target.userData.lifetime / settings.LIFETIME);
            target.scale.set(scale, scale, scale);
            if (target.userData.lifetime <= 0) {
                resetTarget(target);
            }
            target.rotation.y += 0.01;
        });
        renderer.render(scene, camera);
    }

    resetGame();
    animate();
</script>

</body>
</html>